#+AUTHOR:    Anton S. Kosinov
#+TITLE:     Python Desing Patterns
#+SUBTITLE:  exhaustive list
#+EMAIL:     a.s.kosinov@gmail.com
#+LANGUAGE: en
#+STARTUP: showall

* Intro

** Foreword
   #+BEGIN_QUOTE
   Controlling complexity is the essence of computer programming.
   #+BEGIN_EXPORT html
   <p align="right">
   Brian Kernighan
   </p>
   #+END_EXPORT

   All problems in computer science can be solved by another level
   of indirection (abstraction).
   #+BEGIN_EXPORT html
   <p align="right">
   David Wheeler
   </p>
   #+END_EXPORT
   #+END_QUOTE
** Intention
   Design patterns were first introduced by GoF (Gang of Four), where they
   mentioned them as being solutions to given problems. If you would like to
   know more, GoF refers to the four authors of the book, Design Patterns:
   Elements of Reusable Object-Oriented Software. The book's authors are Erich
   Gamma, Richard Helm, Ralph Johnson, and John Vlissides, with a foreword by
   Grady Booch. This book covers software engineering solutions to the commonly
   occurring problems in software design. There were 23 design patterns first
   identified, and the first implementation was done with respect to the Java
   program language. Design patterns are discoveries and not an invention in
   themselves.

** Stem principles

*** The open/close principle
    states that classes or objects and methods should be open for
    extension but closed for modifications.

*** The inversion of control principle
    states that high-level modules shouldn't be dependent on low-level
    modules; they should both be dependent on abstractions. Details
    should depend on abstractions and not the other way round.

*** The interface segregation principle
    clients should not be forced to depend on interfaces they don't
    use.

*** The single responsibility principle
    states, a class should have only one reason to change.

*** The substitution principle
    states that derived classes must be able to completely substitute
    the base classes.

** Advantages of design patterns
   - They are reusable across multiple projects
   - The architectural level of problems can be solved
   - They are time-tested and well-proven, which is the experience of
     developers and architects
   - They have reliability and dependence

** Target audience
   Anybody who are curious in studying and simultaneously appreciate a
   clarity.

** Contribution
   Please feel free to do any corrections, amendments or suggestions.
   /Keep clear, please./
* Overview

** Python3 only
   It is a contemporary version and seems it is used to become the one
   very soon.

** Methodology
*** Brief survey
*** Several examples
*** Test suite

* Structure
  #+BEGIN_SRC shell :results output :exports results
  tree -I '*~|#*|*.pyc|__pycache__'
  #+END_SRC

  #+RESULTS:
  #+begin_example
  .
  ├── patterns
  │   ├── behavioral
  │   │   └── README.org
  │   ├── creational
  │   │   ├── factory
  │   │   │   ├── pet_factory.py
  │   │   │   ├── README.org
  │   │   │   ├── test_pet_factory.py
  │   │   │   ├── test_weapon_factory.py
  │   │   │   └── weapon_factory.py
  │   │   └── README.org
  │   ├── README.org
  │   └── structural
  │       └── README.org
  └── README.org

  5 directories, 10 files
#+end_example

* Corollary

